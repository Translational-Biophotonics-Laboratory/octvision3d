import nrrd
import os
import re
import argparse
import numpy as np
import tifffile as tif
from tqdm import tqdm
from glob import glob
from collections import OrderedDict
from pprint import pprint

# Function to generate new segment data based on the next segment number
def generate_new_segment_data(next_segment_number, name, color):
    base_key = f'Segment{next_segment_number}_'
    new_segment_data = {
        f'{base_key}Color': color,
        f'{base_key}ColorAutoGenerated': '0',
        f'{base_key}Extent': '0 -1 -167 -168 0 -1',
        f'{base_key}ID': f'Segment_{next_segment_number + 1}',
        f'{base_key}Name': name,
        f'{base_key}NameAutoGenerated': '0',
    }
    return new_segment_data

# Function to find the last segment number and its position in the OrderedDict
def find_last_segment_position(odict):
    last_segment_number = -1
    last_segment_key = None
    for key in odict.keys():
        match = re.match(r'Segment(\d+)_', key)
        if match:
            segment_number = int(match.group(1))
            if segment_number > last_segment_number:
                last_segment_number = segment_number
                last_segment_key = key
    return last_segment_number, last_segment_key

# Function to check if a segment with the specified name already exists
def segment_name_already_exists(odict, new_segment_name):
    for key, value in odict.items():
        if key.endswith("_Name") and value == new_segment_name:
            return True
    return False

def add_segmentation_to_header(data, header, nrrd_file_path, new_segment_name, new_segment_color, startedAddingSegments):
    """
    Adds a new segmentation entry to the NRRD file header.

    :param data: nrrd bitmap data.
    :param header: nrrd header OrderedDict
    :param nrrd_file_path: Path to the NRRD file.
    :param new_segment_id: The ID for the new segment.
    """
    if segment_name_already_exists(header, new_segment_name):
        if not startedAddingSegments:
            print(f"WARNING: {new_segment_name} already exists in {nrrd_file_path}. Skipping...")
            return False
        else:
            raise ValueError(f"ERROR: {new_segment_name} exists out of position. Check manually in 3DSlicer")
    else:
        # Find the last segment and calculate the next segment number
        last_segment_number, last_segment_key = find_last_segment_position(header)
        next_segment_number = last_segment_number + 1

        new_segment_data = generate_new_segment_data(next_segment_number, new_segment_name, new_segment_color)
        new_bitmap_data = np.append(data, np.zeros([1] + list(data.shape[1:]), dtype=data.dtype), axis=0)

        # Add new segmentation information to the header
        pattern = re.compile(r"Segment(\d+)")

        # segment_count = len(set([key.split("_")[0] for key in header.keys() if re.match(pattern, key)]))
        onLastSegment = False
        newSegmentAdded = False
        copied_odict = OrderedDict()
        for key, value in header.items():
            if key == "sizes":
                copied_odict[key] = new_bitmap_data.shape
            elif re.match(pattern, key):
                current_segment_num = int(re.match(pattern, key).group(1))
                if current_segment_num == last_segment_number and not newSegmentAdded:
                    onLastSegment = True
                copied_odict[key] = value
            else:
                if onLastSegment and not newSegmentAdded:
                    copied_odict.update(new_segment_data)
                    newSegmentAdded = True
                copied_odict[key] = value

        # Save the NRRD file with the updated header
        nrrd.write(nrrd_file_path, new_bitmap_data, copied_odict)
        #pprint(copied_odict)
        return True

def get_file_paths(path, ext):
    return sorted(glob(f"{path}/*.{ext}"))

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--path",
        type=str,
        required=True,
        help="Path to .seg.nrrd files to add new segments to"
    )
    parser.add_argument(
        "--force",
        type=bool,
        default=False,
        help="Ignore duplicate and just skip over it"
    )
    FLAGS, _ = parser.parse_known_args()

    cmap = OrderedDict([
        ("RET", "0.635 0.0 1.0"),
        ("CHO", "0.56 0.56 0.44"),
        ("VIT", "0.88 0.94 0.99"),
        ("HYA", "0.46 0.98 0.99"),
        ("SHS", "0.69 0.99 0.82"),
        ("ART", "0.99 0.99 0.33"),
        ("ERM", "0.22 0.49 0.97"),
        ("SES", "0.392 0.196 0.0"),
    ])

    # Load the NRRD file

    for f in tqdm(get_file_paths(FLAGS.path, "seg.nrrd")):
        startedAddingSegments = False
        for k, v in cmap.items():
            data, header = nrrd.read(f)
            success = add_segmentation_to_header(data, header, f, k, v, startedAddingSegments)
            if success and not startedAddingSegments:
                startedAddingSegments = True

        data, header = nrrd.read(f)
        header_vals = set([i for i in header.values() if type(i)==str])
        labels = ["CNV", "DRU", "EX", "FLU", "GA", "HEM", "RPE", "RET",\
                  "CHO", "VIT", "HYA", "SHS", "ART", "ERM", "SES"]
        err_s = ""
        for label in labels:
            if label not in header_vals:
                err_s += f", {label}" if len(err_s) != 0 else f"{label}"
        if len(err_s) > 0:
            raise ValueError(f"ERROR: Labels {err_s} not in final header")

