import nrrd
import os
import re
import argparse
import numpy as np
import tifffile as tif
from tqdm import tqdm
from glob import glob
from collections import OrderedDict
from pprint import pprint

# Function to generate new segment data based on the next segment number
def generate_new_segment_data(next_segment_number, name, color):
    base_key = f"Segment{next_segment_number}_"
    new_segment_data = {
        f"{base_key}Color": color,
        f"{base_key}ColorAutoGenerated": "0",
        f"{base_key}Extent": "0 -1 -167 -168 0 -1",
        f"{base_key}ID": f"Segment_{next_segment_number + 1}",
        f"{base_key}Name": name,
        f"{base_key}NameAutoGenerated": "0",
    }
    return new_segment_data

def get_num_segments(odict):
    return len(set([key.split("_")[0] for key in odict.keys() if re.match(r"Segment(\d+)_", key)]))

# Function to find the last segment number and its position in the OrderedDict
def find_last_segment_position(odict):
    last_segment_number = -1
    last_segment_key = None
    for key in odict.keys():
        match = re.match(r"Segment(\d+)_", key)
        if match:
            segment_number = int(match.group(1))
            if segment_number > last_segment_number:
                last_segment_number = segment_number
                last_segment_key = key
    return last_segment_number, last_segment_key

# Function to check if a segment with the specified name already exists
def segment_name_already_exists(odict, new_segment_name):
    for key, value in odict.items():
        if key.endswith("_Name") and value == new_segment_name:
            return True
    return False

def add_segmentation_to_header(data, header, nrrd_file_path, new_segment_name, new_segment_color, startedAddingSegments):
    """
    Adds a new segmentation entry to the NRRD file header.

    :param data: nrrd bitmap data.
    :param header: nrrd header OrderedDict
    :param nrrd_file_path: Path to the NRRD file.
    :param new_segment_id: The ID for the new segment.
    """
    if segment_name_already_exists(header, new_segment_name):
        if not startedAddingSegments:
            print(f"WARNING: {new_segment_name} already exists in {nrrd_file_path}. Skipping...")
            return False
        else:
            raise ValueError(f"ERROR: {new_segment_name} exists out of position. Check manually in 3DSlicer")
    else:
        # Find the last segment and calculate the next segment number
        last_segment_number, last_segment_key = find_last_segment_position(header)
        next_segment_number = last_segment_number + 1

        new_segment_data = generate_new_segment_data(next_segment_number, new_segment_name, new_segment_color)
        new_bitmap_data = np.append(data, np.zeros([1] + list(data.shape[1:]), dtype=data.dtype), axis=0)

        # Add new segmentation information to the header
        pattern = re.compile(r"Segment(\d+)")

        # segment_count = len(set([key.split("_")[0] for key in header.keys() if re.match(pattern, key)]))
        onLastSegment = False
        newSegmentAdded = False
        copied_odict = OrderedDict()
        for key, value in header.items():
            if key == "sizes":
                copied_odict[key] = new_bitmap_data.shape
            elif re.match(pattern, key):
                current_segment_num = int(re.match(pattern, key).group(1))
                if current_segment_num == last_segment_number and not newSegmentAdded:
                    onLastSegment = True
                copied_odict[key] = value
            else:
                if onLastSegment and not newSegmentAdded:
                    copied_odict.update(new_segment_data)
                    newSegmentAdded = True
                copied_odict[key] = value

        # Save the NRRD file with the updated header
        nrrd.write(nrrd_file_path, new_bitmap_data, copied_odict)
        #pprint(copied_odict)
        return True

# Returns True if duplicates, else False
def check_duplicate_labels(header):
    labels = [val for key, val in header.items() if re.match(r"Segment(\d+)_", key) and key.endswith("_Name")]
    if len(labels) != len(set(labels)):
        raise ValueError(f"Duplicate labels found after processing. {labels}")

def get_idx_of_label(header, name):
    for key, val in header.items():
        match = re.match(r"Segment(\d+)_", key)
        if match:
            if key.endswith("_Name") and val == name:
                segment_number = int(match.group(1))
                return segment_number

def delete_by_name(data, header, name, original_labels):
    assert name not in original_labels
    segment_idx = get_idx_of_label(header, name)
    if segment_idx == None:
        return f"WARNING! label {name} not found in header"
    # number <7 should be reserved for original labels and not deleted
    assert segment_idx >= 7

    # Remove entries within the header OrderedDict
    new_header = header.copy()
    for key in header:
        if key.startswith(f"Segment{segment_idx}_"):
            new_header.pop(key)
    new_header["sizes"][0] -= 1

    # Remove corresponding segment channel
    print(f"Deleting idx {segment_idx} from {data.shape}")
    new_data = np.delete(data, segment_idx, axis=0)

    return new_data, new_header
            
def get_file_paths(path, ext):
    return sorted(glob(f"{path}/*.{ext}"))

def remove_data_from_label(data, header, label):
    label_idx = get_idx_of_label(header, label)
    data[label_idx] = np.zeros(data[label_idx].shape)
    return data

def main():
    original_labels = ["CNV", "DRU", "EX", "FLU", "GA", "HEM", "RPE"]
    cmap = OrderedDict([
        ("RET", "0.635 0.0 1.0"),
        ("CHO", "0.56 0.56 0.44"),
        ("VIT", "0.88 0.94 0.99"),
        ("HYA", "0.46 0.98 0.99"),
        ("SHS", "0.69 0.99 0.82"),
        ("ART", "0.99 0.99 0.33"),
        ("ERM", "0.22 0.49 0.97"),
        ("SES", "0.392 0.196 0.0"),
    ])

    # Load the NRRD file
    if os.path.isdir(FLAGS.path):
        for f in tqdm(get_file_paths(FLAGS.path, "seg.nrrd")):
            data, header = nrrd.read(f)
            new_data = remove_data_from_label(data, header, FLAGS.label)

            nrrd.write(f, new_data, header)
    else:
        data, header = nrrd.read(FLAGS.path)
        new_data = remove_data_from_label(data, header, FLAGS.label)

        nrrd.write(FLAGS.path, new_data, header)



if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--path",
        type=str,
        required=True,
        help="Path to .seg.nrrd files to add new segments to"
    )
    parser.add_argument(
        "--label",
        type=str,
        required=True,
        help="Name of label to empty. Does not remove the label but deletes the labels within"
    )
    FLAGS, _ = parser.parse_known_args()
    main()
