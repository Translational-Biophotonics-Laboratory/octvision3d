import nrrd
import os
import re
import argparse
import numpy as np
import tifffile as tif
from tqdm import tqdm
from glob import glob
from collections import OrderedDict
from pprint import pprint

# Function to generate new segment data based on the next segment number
def generate_new_segment_data(next_segment_number, name, color):
    base_key = f"Segment{next_segment_number}_"
    new_segment_data = {
        f"{base_key}Color": color,
        f"{base_key}ColorAutoGenerated": "0",
        f"{base_key}Extent": "0 -1 -167 -168 0 -1",
        f"{base_key}ID": f"Segment_{next_segment_number + 1}",
        f"{base_key}Name": name,
        f"{base_key}NameAutoGenerated": "0",
    }
    return new_segment_data

def get_num_segments(odict):
    return len(set([key.split("_")[0] for key in odict.keys() if re.match(r"Segment(\d+)_", key)]))

# Function to find the last segment number and its position in the OrderedDict
def find_last_segment_position(odict):
    last_segment_number = -1
    last_segment_key = None
    for key in odict.keys():
        match = re.match(r"Segment(\d+)_", key)
        if match:
            segment_number = int(match.group(1))
            if segment_number > last_segment_number:
                last_segment_number = segment_number
                last_segment_key = key
    return last_segment_number, last_segment_key

# Function to check if a segment with the specified name already exists
def segment_name_already_exists(odict, new_segment_name):
    for key, value in odict.items():
        if key.endswith("_Name") and value == new_segment_name:
            return True
    return False

def add_segmentation_to_header(data, header, nrrd_file_path, new_segment_name, new_segment_color, startedAddingSegments):
    """
    Adds a new segmentation entry to the NRRD file header.

    :param data: nrrd bitmap data.
    :param header: nrrd header OrderedDict
    :param nrrd_file_path: Path to the NRRD file.
    :param new_segment_id: The ID for the new segment.
    """
    if segment_name_already_exists(header, new_segment_name):
        if not startedAddingSegments:
            print(f"WARNING: {new_segment_name} already exists in {nrrd_file_path}. Skipping...")
            return False
        else:
            raise ValueError(f"ERROR: {new_segment_name} exists out of position. Check manually in 3DSlicer")
    else:
        # Find the last segment and calculate the next segment number
        last_segment_number, last_segment_key = find_last_segment_position(header)
        next_segment_number = last_segment_number + 1

        new_segment_data = generate_new_segment_data(next_segment_number, new_segment_name, new_segment_color)
        new_bitmap_data = np.append(data, np.zeros([1] + list(data.shape[1:]), dtype=data.dtype), axis=0)

        # Add new segmentation information to the header
        pattern = re.compile(r"Segment(\d+)")

        # segment_count = len(set([key.split("_")[0] for key in header.keys() if re.match(pattern, key)]))
        onLastSegment = False
        newSegmentAdded = False
        copied_odict = OrderedDict()
        for key, value in header.items():
            if key == "sizes":
                copied_odict[key] = new_bitmap_data.shape
            elif re.match(pattern, key):
                current_segment_num = int(re.match(pattern, key).group(1))
                if current_segment_num == last_segment_number and not newSegmentAdded:
                    onLastSegment = True
                copied_odict[key] = value
            else:
                if onLastSegment and not newSegmentAdded:
                    copied_odict.update(new_segment_data)
                    newSegmentAdded = True
                copied_odict[key] = value

        # Save the NRRD file with the updated header
        nrrd.write(nrrd_file_path, new_bitmap_data, copied_odict)
        #pprint(copied_odict)
        return True

# Returns True if duplicates, else False
def check_duplicate_labels(header):
    labels = [val for key, val in header.items() if re.match(r"Segment(\d+)_", key) and key.endswith("_Name")]
    if len(labels) != len(set(labels)):
        raise ValueError(f"Duplicate labels found after processing. {labels}")

def get_idx_of_label(header, name):
    for key, val in header.items():
        match = re.match(r"Segment(\d+)_", key)
        if match:
            if key.endswith("_Name") and val == name:
                segment_number = int(match.group(1))
                return segment_number

def delete_by_name(data, header, name, original_labels):
    assert name not in original_labels
    segment_idx = get_idx_of_label(header, name)
    if segment_idx == None:
        return f"WARNING! label {name} not found in header"
    # number <7 should be reserved for original labels and not deleted
    assert segment_idx >= 7

    # Remove entries within the header OrderedDict
    new_header = header.copy()
    for key in header:
        if key.startswith(f"Segment{segment_idx}_"):
            new_header.pop(key)
    new_header["sizes"][0] -= 1

    # Remove corresponding segment channel
    print(f"Deleting idx {segment_idx} from {data.shape}")
    new_data = np.delete(data, segment_idx, axis=0)

    return new_data, new_header
            
# Function checks that all original labels are present and in the correct order.
def check_order_and_remove_extra_labels(data, header, original_labels):
    name_tracker = list(map(list, zip(original_labels, [-1]*len(original_labels))))
    idx = len(original_labels) - 1
    new_header = header.copy()
    new_data = data.copy()
    for key, val in reversed(header.items()):
        match = re.match(r"Segment(\d+)_", key)
        if match:
            if key.endswith("_Name"):
                segment_number = int(match.group(1))
                if val not in original_labels:
                    if FLAGS.force:
                        print(f"{val} is not in original labels. Force deleting...")
                        new_data, new_header = delete_by_name(new_data, new_header, val, original_labels)
                    else:
                        raise ValueError(f"{val} not one of the original labels. Use --force to delete")
                else:
                    name_tracker[idx][1] = segment_number
                    idx -= 1
    for i, name in enumerate(name_tracker):
        if i != name[1]:
            raise ValueError("Original labels not in proper order")
    return new_data, new_header

def get_file_paths(path, ext):
    return sorted(glob(f"{path}/*.{ext}"))

def get_corrected_header(data, header, original_labels):
    # These labels should be present in every segmentation
    for i in original_labels:
        try:
            assert segment_name_already_exists(header, i)
        except AssertionError as e:
            raise AssertionError(f"{i} label not found in header")
    # Check that the labels are in the correct order
    new_data, new_header = check_order_and_remove_extra_labels(data, header, original_labels)
    return new_data, new_header 

def main():
    original_labels = ["CNV", "DRU", "EX", "FLU", "GA", "HEM", "RPE"]
    cmap = OrderedDict([
        ("RET", "0.635 0.0 1.0"),
        ("CHO", "0.56 0.56 0.44"),
        ("VIT", "0.88 0.94 0.99"),
        ("HYA", "0.46 0.98 0.99"),
        ("SHS", "0.69 0.99 0.82"),
        ("ART", "0.99 0.99 0.33"),
        ("ERM", "0.22 0.49 0.97"),
        ("SES", "0.392 0.196 0.0"),
    ])


    # Load the NRRD file
    for f in tqdm(get_file_paths(FLAGS.path, "seg.nrrd")):
        startedAddingSegments = False

        data, header = nrrd.read(f)

        # run tests to ensure seg.nrrd header is correct
        corrected_data, corrected_header = get_corrected_header(data, header, original_labels)
        nrrd.write(f, corrected_data, corrected_header)

        # Add new labels
        for k, v in cmap.items():
            data, header = nrrd.read(f)
            success = add_segmentation_to_header(data, header, f, k, v, startedAddingSegments)
            if success and not startedAddingSegments:
                startedAddingSegments = True

        data, header = nrrd.read(f)
        header_vals = set([i for i in header.values() if type(i)==str])
        labels = ["CNV", "DRU", "EX", "FLU", "GA", "HEM", "RPE", "RET",\
                  "CHO", "VIT", "HYA", "SHS", "ART", "ERM", "SES"]
        err_s = ""
        for label in labels:
            if label not in header_vals:
                err_s += f", {label}" if len(err_s) != 0 else f"{label}"
        if len(err_s) > 0:
            raise ValueError(f"ERROR: Labels {err_s} not in final header")

        # check for duplicates at the end as well
        check_duplicate_labels(header)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--path",
        type=str,
        required=True,
        help="Path to .seg.nrrd files to add new segments to"
    )
    parser.add_argument(
        "--force",
        default=False,
        action="store_true",
        help="Delete labels not in original labels"
    )
    FLAGS, _ = parser.parse_known_args()
    main()
