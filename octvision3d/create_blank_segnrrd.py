# This script generates new, "blank" .seg.nrrd segmentation files for each .tif image in a given directory.
# For each image (excluding those containing "slo" in the filename), it creates a zero-initialized
# 4D segmentation volume with 15 labeled channels and injects standardized metadata and colormap 
# entries into the NRRD header. If a .seg.nrrd file already exists, it is skipped. This is used
# to bootstrap label files for annotation workflows in 3D Slicer or similar tools.

import nrrd
import os
import re
import argparse
import numpy as np
import tifffile as tif
from tqdm import tqdm
from glob import glob
from collections import OrderedDict
from octvision3d.utils import get_filenames

def add_new_segnrrd(nrrd_file_path, header, cmap, data):
    """
    Create a new .seg.nrrd file by injecting a fresh set of segments into the header.

    Parameters:
    - nrrd_file_path: str, path to the output NRRD file to write
    - header: collections.OrderedDict, existing NRRD header to update
    - cmap: dict, mapping from segment name (str) to RGB color string (e.g., "255 0 0")
    - data: np.ndarray, 4D or 3D array representing the segmentation mask volume

    Returns:
    - None. Writes a new .seg.nrrd file to `nrrd_file_path`
    """
    for segment_count, (key, value) in enumerate(cmap.items()):
        new_segment_id = f"Segment_{segment_count+1}"
        header[f'Segment{segment_count}_Color'] = value
        header[f'Segment{segment_count}_ColorAutoGenerated'] = '0'  # Assuming color is manually set
        header[f'Segment{segment_count}_Extent'] = '0 -1 -167 -168 0 -1'
        header[f'Segment{segment_count}_ID'] = new_segment_id
        header[f'Segment{segment_count}_Name'] = key
        header[f'Segment{segment_count}_NameAutoGenerated'] = '0'  # Assuming color is manually set

    # Save the NRRD file with the updated header
    nrrd.write(nrrd_file_path, data, header)

def main():
    header = OrderedDict([
        ("type", "uint8"),
        ("dimension", 4),
        ("space", "right-anterior-superior"),
        ("sizes", np.array([14,1,1,1])),
        ("space directions", np.array([[np.nan,np.nan,np.nan],[1.,-0.,0.],[-0.,1.,-0.],[0.,-0.,1.]])),
        ("kinds", ["list","domain","domain","domain"]),
        ("encodin", "gzip"),
        ("space origin", np.array([-0.,0.,-0.])),
        ("measurement frame", np.array([[1.,0.,0.],[0.,1.,0.],[0.,0.,1.]])),
    ])
    cmap = OrderedDict([
        ("CNV", "0.502 0.682 0.502"),
        ("DRU", "0.945 0.839 0.569"),
        ("EX", "0.694 0.478 0.396"),
        ("FLU", "0.435 0.722 0.824"),
        ("GA", "0.847 0.396 0.310"),
        ("HEM", "0.867 0.510 0.396"),
        ("RPE", "0.565 0.933 0.565"),
        ("RET", "0.635 0.0 1.0"),
        ("CHO", "0.56 0.56 0.44"),
        ("VIT", "0.88 0.94 0.99"),
        ("HYA", "0.46 0.98 0.99"),
        ("SHS", "0.69 0.99 0.82"),
        ("ART", "0.99 0.99 0.33"),
        ("ERM", "0.22 0.49 0.97"),
        ("SES", "0.392 0.196 0.0"),
    ])
    for f in tqdm(get_filenames(FLAGS.path, "tif")):
        if "slo" in f.lower():
            continue
        nrrd_f = os.path.splitext(f)[0] + ".seg.nrrd"
        if os.path.exists(nrrd_f):
            print(f"Skipping {f}...{nrrd_f} already exists")
            continue

        data = np.zeros((len(cmap.keys()), 1, 1, 1), dtype=np.uint8)
        # This does write to the file each time per loop, but I would get
        # invalid file outputs if I didn't do it this way
        for k, v in cmap.items():
            add_new_segnrrd(nrrd_f, header, cmap, data)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--path",
        type=str,
        required=True,
        help="Path to .seg.nrrd files to add new segments to"
    )
    FLAGS, _ = parser.parse_known_args()
    main()

